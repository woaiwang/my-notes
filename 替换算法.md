# 替换算法

# Cache 主存数据块替换（淘汰）算法总结笔记

## 总览

当发生 Cache 缺失（Miss）且目标集合/行已满时，需要从 Cache 中选出一个现有数据块淘汰，以装入新的主存数据块。替换策略直接影响：

- 命中率（Hit Rate）
- 有效访问时间（EAT）
- 硬件实现复杂度与成本
- 能否反映程序的时间/空间局部性

本文对四类基础算法进行整理：随机替换（Random）、先进先出（FIFO）、最不经常使用（LFU）、近期最少使用（LRU）。

---

## 1. 随机替换（Random Replacement）

**基本思想**：随机选择一个 Cache 行进行替换。  
**实现方法**：为目标集合随机产生一个行号（可用线性反馈移位寄存器 LFSR 等伪随机源）。  
**优点**：

- 硬件最简单，速度快
- 不需要记录访问历史或顺序  
  **缺点**：
- 可能淘汰“刚好要再次使用”的热数据，降低命中率
- 在高局部性工作负载下表现差于 LRU/LFU  
  **补充说明**：
- 随容量增大，随机误淘汰的负面影响下降
- 实际仿真中常仅略好于或略差于 FIFO，明显逊于改良的 LRU 变体

---

## 2. 先进先出（FIFO）

**基本思想**：按块被装入（进入 Cache）的时间顺序，最早进入者最先被淘汰。  
**实现方法**：记录每个 Cache 行的“装入时间戳”或维护队列指针。  
**优点**：

- 实现较简单（时间戳或环形队列）
- 开销低（仅需顺序信息）  
  **缺点**：
- 不考虑后续访问频度与近期性，可能淘汰当前依然高频访问的数据块
- 对具有强时间局部性的应用不理想  
  **常见问题（Belady 异常相关思想）** ：
- 在某些访问序列中，增加 Cache 容量不一定提高命中率（FIFO 可能出现所谓“异常”）。  
  **适用场景**：
- 对硬件成本极度敏感的简单嵌入式系统
- 或作为更复杂策略的基线参照

---

## 3. 最不经常使用（LFU：Least Frequently Used）

**基本思想**：淘汰“历史累计访问次数最少”的 Cache 行。  
**实现方法**：

1. 每行维护一个访问计数器（载入后初始化为 0）。
2. 每次命中或被访问行的计数器加 1。
3. 需替换时选计数值最小的行。  
    **优点**：

- 试图保留“长期热点”数据  
  **缺点**：
- 计数器硬件成本较高（每行一个，且可能需要较宽位数）
- 不能很好反映“近期性”：旧的历史访问会永久抬高计数（需周期性衰减或重置机制，否则“黏住”）
- 对阶段性工作负载（Phase Behavior）适应差  
  **改进方向**：
- 引入衰减（Aging）：定期右移或乘以系数，降低远古访问权重
- 设置最大值饱和，避免溢出与过度偏置  
  **适用场景**：
- 访问模式稳定、热点持久的服务器缓存（需结合 Aging 才更有效）

---

## 4. 近期最少使用（LRU：Least Recently Used）

**基本思想**：淘汰“最长时间未被访问”的 Cache 行，假设最近使用的数据未来仍可能被再次使用（时间局部性原则）。  
**实现方法（典型）** ：

1. 每次命中更新该行的“最近使用次序”（链表、栈式顺序或时间戳）。
2. 发生替换时选出最久未访问的行。  
    **硬件实现方式**：

- 低路（如 2/4 路）集合：用若干位编码次序（Pseudo-LRU / 位标记）。
- 高路集合：完全 LRU 代价高（需维护有序结构），常改用近似算法（Pseudo-LRU、Tree-LRU、NRU）。  
  **优点**：
- 能较好反映“近期性”，在多数带时间局部性的程序中命中率高  
  **缺点**：
- 硬件复杂度高于 FIFO/Random（尤其高关联度）
- 对“循环访问超过 Cache 容量”模式可能性能下降（大工作集逐步驱逐）  
  **近似/变体**：
- NRU（Not Recently Used）：设置引用位，定期清零，选未被引用者淘汰
- Pseudo-LRU（树形位图）：用二叉树方向位近似记录最久未用路径  
  **适用场景**：
- 大多数通用处理器的一级、二级 Cache（常用近似实现）

---

## 四算法对比总表

|算法|核心度量|需要记录的数据|硬件复杂度|优势|劣势|对局部性的适应|
| --------| --------------| -----------------| -----------------------| ----------------------| ----------------------------| ------------------|
|Random|无|无（随机源）|极低|最简单，延迟最小|命中率一般或偏低|几乎不利用局部性|
|FIFO|进入顺序|时间戳/队列指针|低|实现容易，稳定|不考虑访问频度与近期性|弱|
|LFU|累计频度|访问计数器|中-高|保留长期热点|不反映近期性，需要衰减策略|中等（需改进）|
|LRU|最近访问时间|次序结构/标志位|中-高（随关联度增加）|利用时间局部性效果好|成本高，在大集合需近似|强|

---

## 设计与选择建议

1. 小型低功耗系统：Random 或 FIFO（简化硬件）。
2. 通用 CPU L1/L2：Pseudo-LRU（折中性能与复杂度）。
3. 大型共享 Last-Level Cache：可能采用多策略融合（例如最近性 + 访问频度 + 退避机制）。
4. 当工作负载存在“相位变化”时，纯 LFU 若无 Aging 会滞后；需周期性重置或指数衰减。
5. 评估指标：

    - 平均访问延迟：Hit_Time + Miss_Rate * Miss_Penalty
    - Miss 类型分析：Cold / Capacity / Conflict（替换策略主要改善 Capacity & Conflict）。
6. 测试与验证：

    - 使用真实 Trace（SPEC、PARSEC）或模拟器（gem5）比较 Miss Rate
    - 观察不同工作集大小与关联度下的敏感性

---

## 常见误区与注意事项

- 误区：LRU 一定最好。实际上高关联度下的真实 LRU 代价巨大，近似可能偏离，且某些访问模式（大环）性能不佳。
- 误区：LFU 等价于“热点保留”。若没有老化机制，旧热点会阻塞新热点进入。
- 注意：评估策略需考虑替换元数据的访问能耗及面积开销（元数据本身可能影响频率与功耗）。
- 注意：在多核/共享缓存中，替换策略还可能与公平性、QoS、隔离策略耦合（如为不同进程维护独立计数或分区）。

---

## 记忆速览（口诀式）

- Random：快而“盲”，命中率看天。
- FIFO：按“进门先后”走人，不看后来表现。
- LFU：看“访问总次数”，需防“旧爱挥之不去”。
- LRU：抓“最近使用”，最贴近时间局部性。

---

## 进一步扩展方向（超出图片原始内容）

- ARC（Adaptive Replacement Cache）：结合近期性与频度双列表自适应调节。
- CLOCK / Second-Chance：近似 LRU，利用环指针 + 引用位，降低开销。
- RRIP（Re-Reference Interval Prediction）：用重访问间隔预测改善多核高压场景。
- DIP（Dynamic Insertion Policy）：在 LRU 与其他策略间动态选择插入位置。

---

## 小结

选择替换算法需综合考虑：

- 访问模式局部性（时间/空间）
- 硬件预算（面积、功耗、时序）
- 关联度 & 层级（L1 vs LLC）
- 系统目标（通用性能 vs 能耗 vs QoS）

LRU（或其近似）仍是多数场景的良好默认；在极端资源受限或访问模式特殊时，引入 Random/FIFO/LFU 或更高级自适应算法以求更优的命中与成本平衡。

---

![屏幕截图 2025-11-07 193608](assets/屏幕截图%202025-11-07%20193608-20251107200551-v02bt2r.png)

![屏幕截图 2025-11-07 200640](assets/屏幕截图%202025-11-07%20200640-20251107200644-107ojx3.png)
