# 回溯算法

# 基础知识

## 尝试与回退

**之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略**。当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择。

> 例题二：在二叉树中搜索所有值为 7 的节点，**请返回根节点到这些节点的路径**。

```c++
/* 前序遍历：例题二 */
void preOrder(TreeNode *root) {
    if (root == nullptr) {
        return;
    }
    // 尝试
    path.push_back(root);
    if (root->val == 7) {
        // 记录解
        res.push_back(path);
    }
    preOrder(root->left);
    preOrder(root->right);
    // 回退
    path.pop_back();//这一步是回退，就是恢复
}
```

## 剪枝

复杂的回溯问题通常包含一个或多个约束条件，**约束条件通常可用于“剪枝”** 。

>  例题三：在二叉树中搜索所有值为 7 的节点，请返回根节点到这些节点的路径，**并要求路径中不包含值为 3 的节点**。

```c++
/* 前序遍历：例题三 */
void preOrder(TreeNode *root) {
    // 剪枝，加入了约束条件，提前返回，不用看三后面的结果
    if (root == nullptr || root->val == 3) {
        return;
    }
    // 尝试
    path.push_back(root);
    if (root->val == 7) {
        // 记录解
        res.push_back(path);
    }
    preOrder(root->left);
    preOrder(root->right);
    // 回退
    path.pop_back();
}
```

|名词|定义|例题三|
| ----------| ----------------------------------------------------------------------------| -------------------------------------------------------------------|
|解|解是满足问题特定条件的答案，可能有一个或多个|根节点到节点 7 的满足约束条件的所有路径|
|约束条件|约束条件是问题中限制解的可行性的条件，通常用于剪枝|路径中不包含节点3|
|状态|状态表示问题在某一时刻的情况，包括已经做出的选择|当前已访问的节点路径，即 path 节点列表|
|尝试|尝试是根据可用选择来探索解空间的过程，包括做出选择，更新状态，检查是否为解|递归访问左（右）子节点，将节点添加进 `path`​ ，判断节点的值是否为7|
|回退|回退指遇到不满足约束条件的状态时，撤销前面做出的选择，回到上一个状态|当越过叶节点、结束节点访问、遇到值为 3 的节点时终止搜索，函数返回|
|剪枝|剪枝是根据问题特性和约束条件避免无意义的搜索路径的方法，可提高搜索效率|当遇到值为 3 的节点时，则不再继续搜索|

## 优点与局限性

回溯算法本质上是一种深度优先搜索算法，它尝试所有可能的解决方案直到找到满足条件的解。这种方法的优点在于能够找到所有可能的解决方案，而且在合理的剪枝操作下，具有很高的效率。

然而，在处理大规模或者复杂问题时，**回溯算法的运行效率可能难以接受**。

- **时间**：回溯算法通常需要遍历状态空间的所有可能，时间复杂度可以达到指数阶或阶乘阶。
- **空间**：在递归调用中需要保存当前的状态（例如路径、用于剪枝的辅助变量等），当深度很大时，空间需求可能会变得很大。

即便如此，**回溯算法仍然是某些搜索问题和约束满足问题的最佳解决方案**。对于这些问题，由于无法预测哪些选择可生成有效的解，因此我们必须对所有可能的选择进行遍历。在这种情况下，**关键是如何优化效率**，常见的效率优化方法有两种。

- **剪枝**：避免搜索那些肯定不会产生解的路径，从而节省时间和空间。
- **启发式搜索**：在搜索过程中引入一些策略或者估计值，从而优先搜索最有可能产生有效解的路径。

‍

# 练习题

## 二叉树的所有路径

> 给你一个二叉树的根节点 `root`​ ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。
>
> **叶子节点** 是指没有子节点的节点。

![image](assets/image-20250616194841-se9q2xj.png)​

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    vector<string> ans;
    vector<string> path;
    void dfs(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        path.push_back(to_string(root->val));
        if (root->left == root->right) {//约束条件：当遇到叶子节点
            string lastpath;
            for (int i = 0; i < path.size(); i++) {
                if (i > 0) {
                    lastpath += "->" + path[i];
                } else {
                    lastpath += path[i];
                }
            }
            ans.push_back(lastpath);
        }
        dfs(root->left);
        dfs(root->right);
        path.pop_back();//回退，恢复现场。当某个节点的左子树和右子树都完成，就再往上回溯
    }
    vector<string> binaryTreePaths(TreeNode* root) {

        dfs(root);
        return ans;
    }
};
```

# 组合

## 题目

给定两个整数 `n`​ 和 `k`​，返回范围 `[1, n]`​ 中所有可能的 `k`​ 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例 1：**

**输入：** n = 4, k = 2  
**输出：**   
[  
  [2,4],  
  [3,4],  
  [2,3],  
  [1,2],  
  [1,3],  
  [1,4],  
]

## 分析

- 给定整数n,输出所有k个数的组合，可以想到用回溯法
- 当有4个数时（1,2,3,4），要求选两个数，先定义一个start（开始选数的位置），比如在第一层时，start可以是1,2,3，但是不能是4，因为从4开始选就选不够四个数。
- 再定义一个balance，（表示需要选的剩余的数），当balance=0时，就说明不用选了，将当前路径加入到ans中。
- 接下来就能定义递归函数了dfs(int n,int blance,int start)

```c++
class Solution {
public:
    vector<vector<int>>ans;//最终答案
    vector<int>path;//每一个路径
    int blance;
    void dfs(int n,int blance,int start)
    {
        if(blance==0)//终止条件
        {
            ans.push_back(path);
            return;
        }
        for(int i=start;i<=n-blance+1;i++)//从start开始，到n-balance+1结束
        {
            path.push_back(i);//选到的数加入路径
            dfs(n,blance-1,i+1);//再继续选
            path.pop_back();//恢复现场

        }

    }
    vector<vector<int>> combine(int n, int k) {
        dfs(n,k,1);
        return ans;
    }
};
```

最终选到的数会是这种形式输出

[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]

‍

# 回文串

## 题目

给你一个字符串 `s`​，请你将 `s`​ 分割成一些 子串，使每个子串都是 **回文串** 。返回 `s`​ 所有可能的分割方案。

**示例 1：**

**输入：** s = "aab"  
**输出：** [["a","a","b"],["aa","b"]]

**示例 2：**

**输入：** s = "a"  
**输出：** [["a"]]

## 分析

- 首先想到的是如何把这个字符串划分开
- - 每一个回溯都会联想到树的结构，所以能想到可以从字母的开始划分，比如aadef划分为a开头，a开头，d开头，e开头等
  - 每一个开头又能往下推导
- 其次就是判断是否为回文串，这里用了动态规划

```c++
class Solution {
public:
    vector<vector<string>>ans;
    vector<string>path;
    vector<vector<int>>dp;
    int check(string& s, int l, int r) {//检查是否为回文串
        if (dp[l][r] != 0) {
            return dp[l][r];
        }
        if (l >= r) {
            return dp[l][r] = 1; // 单个字符或空串是回文
        }
        if (s[l] == s[r]) {
            return dp[l][r] = check(s, l + 1, r - 1);
        } else {
            return dp[l][r] = -1; // 不是回文
        }
    }
    void dfs(string s,int start)//回溯算法，start是开始字符的下标
    {
        if(start==s.size())//当下标等于字符串长度时，说明到最后的位置了，也就是树的底部
        {
            ans.push_back(path);
            return;
        }
        for(int i=start;i<s.size();i++)
        {
            if(check(s,start,i)==1)//如果满足回文串
            {
            path.push_back(s.substr(start,i-start+1));//就把字符串放进path中
            dfs(s,i+1);//按当前的继续递归下去，直到递归到底部，树的一条枝干已经结束
            path.pop_back();//恢复原状，下一次再递归另一条枝干
            }
            

        }
    }
    vector<vector<string>> partition(string s) {
        int n=s.size();
         dp.assign(n, vector<int>(n));
        dfs(s,0);
        return ans;
        
    }
};
```

# n皇后

## 题目

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n`​ 个皇后放置在 `n×n`​ 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n`​ ，返回所有不同的 **n**    **皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'`​ 和 `'.'`​ 分别代表了皇后和空位。

### **示例 1：**

**输入：** n = 4  
**输出：** [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]  
**解释：** 如上图所示，4 皇后问题存在两个不同的解法。

### **示例 2：**

**输入：** n = 1  
**输出：** [["Q"]]

## 解题思路

1. 这是一道经典的回溯问题，把每一行看做是树的每一层，因为每一行只能放一个皇后，用一个queen数组大小为n用于存储对应的列，比如quuen[2]=3意思是第二行的皇后存在第三列
2. 上面解决了皇后存放的问题，下面看看题目中的限制条件应该怎么解决

    1. 每一列只能放一个皇后，这个好办，设置一个数组，把已经占用的列放入，在判断新皇后时，新皇后就不能放入这些占用的列
    2. 左上到右下的斜线，这个是有点难，但是随便挑两个斜线找找规律就能发现，如果在同一斜线，那么他们的行列之差相同，和上一个条件一样，也设置一个数组，用于存放行列之差，要是新皇后的行列之差在这个数组当中，就不能放入
    3. 右上到左下和上一条相似，在一个斜线的 他们的行列之和相同，剩下的就和上一个条件一样。
3. 以上就把回溯的判断条件都分析完了，在写回溯时，当判断完最后一行后，就能把结果放入最后的答案中

## 代码

```c++
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>>ans;
        vector<int>queen(n,-1);
        vector<int>col;//这里也可以用集合，集合比较方便
        vector<int>le_ri;
        vector<int>ri_le;
        backfun(ans,0,n,queen,col,le_ri,ri_le);
        return ans;
        
    }
    void backfun(vector<vector<string>>& ans,int row,int n,vector<int>&queen,vector<int>&col,vector<int>&le_ri,vector<int>&ri_le)
    {
        if(row==n)//当所有行判断结束，就加入一个答案
        {
            vector<string>last=generateBoard(queen,n);
            ans.push_back(last);
        }
        for(int i=0;i<n;i++)
        {
            auto it1 = std::find(col.begin(), col.end(), i);
            if(it1!=col.end())//分别对应那三个条件
            {
                continue;
            }
            int dis=row-i;
            auto it2 = std::find(le_ri.begin(), le_ri.end(), dis);
            if(it2!=le_ri.end())
            {
                continue;
            }
            int add=row+i;
            auto it3 = std::find(ri_le.begin(), ri_le.end(), add);
            if(it3!=ri_le.end())
            {
                continue;
            }
            col.push_back(i);
            le_ri.push_back(dis);
            ri_le.push_back(add);
            queen[row]=i;//这里是将条件改变
            backfun(ans,row+1,n,queen,col,le_ri,ri_le);//，如果上面的条件都满足，接着进入下一行
            col.pop_back();//恢复状态
            le_ri.pop_back();
            ri_le.pop_back();
            queen[row]=-1;

        }
    }
    vector<string> generateBoard(vector<int> &queens, int n) {
        auto board = vector<string>();
        for (int i = 0; i < n; i++) {
            string row = string(n, '.');
            row[queens[i]] = 'Q';
            board.push_back(row);
        }
        return board;
    }

};
```
