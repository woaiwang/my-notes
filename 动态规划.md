# 动态规划

> 在上一节中，我们学习了动态规划是如何通过子问题分解来求解原问题的。实际上，子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同。
>
> - 分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解。
> - 动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题。
> - 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题。
>
> 实际上，动态规划常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性。

## DP类型问题

> 给定一个楼梯，你每步可以上 1 阶或者 2 阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组 cost ，其中 cost[i] 表示在第 i 个台阶需要付出的代价，cost[0] 为地面（起始点）。请计算最少需要付出多少代价才能到达顶部？

### 分析题目

‍

‍

- 原问题的最优解是从子问题中构建出来的（判断是否是动态规划类型）
- 找出状态转移方程 **dp[i]=min(dp[i−1], dp[i−2])+cost[i]**
- 找到边界条件以及初始状态 dp[1]\=cost[1] 和 dp[2]\=cost[2]

  ```c++
  /* 爬楼梯最小代价：动态规划 */
  int minCostClimbingStairsDP(vector<int> &cost) {
      int n = cost.size() - 1;
      if (n == 1 || n == 2)
          return cost[n];
      // 初始化 dp 表，用于存储子问题的解
      vector<int> dp(n + 1);
      // 初始状态：预设最小子问题的解
      dp[1] = cost[1];
      dp[2] = cost[2];
      // 状态转移：从较小子问题逐步求解较大子问题
      for (int i = 3; i <= n; i++) {
          dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
      }
      return dp[n];
  }
  ```

![image](assets/image-20250513195807-3hokspp.png)

‍

‍

## 01背包问题

>  给定 n 个物品，第 i 个物品的重量为 wgt[i−1]、价值为 val[i−1] ，和一个容量为 cap 的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。

### 分析题目

1. **思考每轮的决策，定义状态，从而得到 dp 表**

    - 对于每一个物品来说，有放和不放两种选择，设dp[i,c](表示为前i个物品在容量为c的最大价值

      - 不放第i个物品：dp[i,c]=dp[i-1,c]
      - 放第i个物品：dp[i,c]=dp[i-1,c-wgt[i-1]]+val[i-1]

    ‍
2. **第二步：找出最优子结构，进而推导出状态转移方程**

    - 上述分析向我们揭示了本题的最优子结构：**最大价值 dp[i,c] 等于不放入物品 i 和放入物品 i 两种方案中价值更大的那一个**。由此可推导出状态转移方程：

      dp[i,c]\=max(dp[i−1,c],dp[i−1,c−wgt[i−1]]+val[i−1])

      需要注意的是，若当前物品重量 wgt[i−1] 超出剩余背包容量 c ，则只能选择不放入背包。

3. **确定边界条件和状态转移顺序**

```c++
/* 0-1 背包：暴力搜索 */
int knapsackDFS(vector<int> &wgt, vector<int> &val, int i, int c) {
    // 若已选完所有物品或背包无剩余容量，则返回价值 0
    if (i == 0 || c == 0) {
        return 0;
    }
    // 若超过背包容量，则只能选择不放入背包
    if (wgt[i - 1] > c) {
        return knapsackDFS(wgt, val, i - 1, c);
    }
    // 计算不放入和放入物品 i 的最大价值
    int no = knapsackDFS(wgt, val, i - 1, c);
    int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];
    // 返回两种方案中价值更大的那一个
    return max(no, yes);
}
```

```c++
/* 0-1 背包：动态规划 */
int knapsackDP(vector<int> &wgt, vector<int> &val, int cap) {
    int n = wgt.size();
    // 初始化 dp 表
    vector<vector<int>> dp(n + 1, vector<int>(cap + 1, 0));
    // 状态转移
    for (int i = 1; i <= n; i++) {
        for (int c = 1; c <= cap; c++) {
            if (wgt[i - 1] > c) {
                // 若超过背包容量，则不选物品 i
                dp[i][c] = dp[i - 1][c];
            } else {
                // 不选和选物品 i 这两种方案的较大值
                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);
            }
        }
    }
    return dp[n][cap];
}
```

​#https://leetcode.cn/problems/partition-equal-subset-sum/solutions/3676890/0-1bei-bao-yu-zhe-dao-ti-de-guan-xi-by-y-g2n9/#​

‍

## 完全背包问题

> 由0-1背包演变而来，最大的差别是0-1背包中每个物体只能使用一次，而完全背包中物体可以重复选。

### 问题描述

给定 n 个物品，第 i 个物品的重量为 wgt[i−1]、价值为 val[i−1] ，和一个容量为 cap 的背包。**每个物品可以重复选取**，问在限定背包容量下能放入物品的最大价值。示例如图 14-22 所示。

![image](assets/image-20250517084029-zgv026g.png)​

完全背包问题和 0-1 背包问题非常相似，**区别仅在于不限制物品的选择次数**。

- 在 0-1 背包问题中，每种物品只有一个，因此将物品 i 放入背包后，只能从前 i−1 个物品中选择。
- 在完全背包问题中，每种物品的数量是无限的，因此将物品 i 放入背包后，**仍可以从前 i 个物品中选择**。

在完全背包问题的规定下，状态 [i,c] 的变化分为两种情况。

- **不放入物品 i** ：与 0-1 背包问题相同，转移至 [i−1,c] 。
- **放入物品 i**<span data-type="text" style="background-color: var(--b3-card-error-background); color: var(--b3-card-error-color);"> ：与 0-1 背包问题不同，转移至 [i,c−</span>wgt[i−1]<span data-type="text" style="background-color: var(--b3-card-error-background); color: var(--b3-card-error-color);">] 。</span>

从而状态转移方程变为：<span data-type="text" style="background-color: var(--b3-card-success-background); color: var(--b3-card-success-color);">dp[i,c]=max(dp[i-1,c],dp[i,c-wgt[i-1]]+val[i-1])</span>

>  如果不放入第i个物体，书包就还是和[i-1,c]相同
>
> 如果放入第i个物品，在0-1背包中是[i-1,c-wgt[i-1]],在 完全背包问题中[i,c−wgt[i−1]]

‍

## 编辑距离问题

> 题目：
>
> 输入两个字符串 s 和 t ，返回将 s 转换为 t 所需的最少编辑步数。
>
> 你可以在一个字符串中进行三种编辑操作：插入一个字符、删除一个字符、将字符替换为任意一个字符。

### 1思考每一步的决策

我们希望在编辑操作的过程中，问题的规模逐渐缩小，这样才能构建子问题。设字符串 s 和 t 的长度分别为 n 和 m ，我们先考虑两字符串尾部的字符 s[n−1] 和 t[m−1] 。

- 若 s[n−1] 和 t[m−1] 相同，我们可以跳过它们，直接考虑 s[n−2] 和 t[m−2] 。
- 若 s[n−1] 和 t[m−1] 不同，我们需要对 s 进行一次编辑（插入、删除、替换），使得两字符串尾部的字符相同，从而可以跳过它们，考虑规模更小的问题。

也就是说，我们在字符串 s 中进行的每一轮决策（编辑操作），都会使得 s 和 t 中剩余的待匹配字符发生变化。因此，状态为当前在 s 和 t 中考虑的第 i 和第 j 个字符，记为 [i,j] 。

状态 [i,j] 对应的子问题：**将 s 的前 i 个字符更改为 t 的前 j 个字符所需的最少编辑步数**。

至此，得到一个尺寸为 (i+1)×(j+1) 的二维 dp 表。

### 2,找状态状态转移方程

考虑子问题 dp[i,j] ，其对应的两个字符串的尾部字符为 s[i−1] 和 t[j−1] ，可根据不同编辑操作分为图 14-29 所示的三种情况。

1. 在 s[i−1] 之后添加 t[j−1] ，则剩余子问题 dp[i,j−1] 。
2. 删除 s[i−1] ，则剩余子问题 dp[i−1,j] 。
3. 将 s[i−1] 替换为 t[j−1] ，则剩余子问题 dp[i−1,j−1] 。

    ![image](assets/image-20250518170551-214j1ua.png)

根据以上分析，可得最优子结构：dp[i,j] 的最少编辑步数等于 dp[i,j−1]、dp[i−1,j]、dp[i−1,j−1] 三者中的最少编辑步数，再加上本次的编辑步数 1 。对应的状态转移方程为：

dp[i,j]\=min(dp[i,j−1],dp[i−1,j],dp[i−1,j−1])+1

请注意，**当 s[i−1] 和 t[j−1] 相同时，无须编辑当前字符**，这种情况下的状态转移方程为：

dp[i,j]\=dp[i-1,j-1]

### 确定边界条件

当两字符串都为空时，编辑步数为 0 ，即 dp[0,0]\=0 。当 s 为空但 t 不为空时，最少编辑步数等于 t 的长度，即首行 dp[0,j]\=j 。当 s 不为空但 t 为空时，最少编辑步数等于 s 的长度，即首列 dp[i,0]\=i 。

观察状态转移方程，解 dp[i,j] 依赖左方、上方、左上方的解，因此通过两层循环正序遍历整个 dp 表即可。

### 代码实现

```c++
/* 编辑距离：动态规划 */
int editDistanceDP(string s, string t) {
    int n = s.length(), m = t.length();
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
    // 状态转移：首行首列
    for (int i = 1; i <= n; i++) {
        dp[i][0] = i;
    }
    for (int j = 1; j <= m; j++) {
        dp[0][j] = j;
    }
    // 状态转移：其余行和列
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (s[i - 1] == t[j - 1]) {
                // 若两字符相等，则直接跳过此两字符
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                // 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1
                dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;
            }
        }
    }
    return dp[n][m];
}
```

# 练习题

## 例题一：单词拆分

### 题目

给你一个字符串 `s`​ 和一个字符串列表 `wordDict`​ 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s`​ 则返回 `true`​。

**注意：** 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

**输入:**  s = "leetcode", wordDict = ["leet", "code"]  
**输出:**  true  
**解释:**  返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

**示例 2：**

**输入:**  s = "applepenapple", wordDict = ["apple", "pen"]  
**输出:**  true  
**解释:**  返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。  
     注意，你可以重复使用字典中的单词。

**示例 3：**

**输入:**  s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]  
**输出:**  false

### 分析

1. 这是一道动态规划中dp类型问题
2. 首先要知道dp的含义，dp[i]表示前i个字符串是否满足要求，题目需要返回的是dp[n],（也就是指前n个字符串是否满足）
3. 其次我们来看初始状态dp[0],可以设置为true,因为空字符串肯定满足
4. 接下来我们看状态转移方程dp[i]应该是什么。在确认前i个字符串是否满足时，必须要做的是遍历整个字符串，用j来遍历字符串，当dp[j]=true时，说明前j个字符已经判断好了，只要j到i的字符在单词表就足够了，这样就能不断的完善dp数组
5. 最后返回dp[n]就行。

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string>set;//设置一个集合，便于查找
        for(int i=0;i<wordDict.size();i++)
        {
            set.insert(wordDict[i]);
        }
        int n=s.size();
        vector<int>dp(n+1,0);
        dp[0]=1;//设置初始值
        for(int i=1;i<=n;i++)
        {
            for(int j=0;j<i;j++)
            {
                if(dp[j]==1&&set.find(s.substr(j,i-j))!=set.end())//dp[i]的更新条件
                {
                    dp[i]=1;
                    break;
                }
            }
        }
        return dp[n];//返回即可
    }
};
```

‍

## 例题二：最长回文子串

### 给你一个字符串 `s`​，找到 `s`​ 中最长的 回文 子串。

**示例 1：**

**输入：** s = "babad"  
**输出：** "bab"  
**解释：** "aba" 同样是符合题意的答案。

**示例 2：**

**输入：** s = "cbbd"  
**输出：** "bb"

#### 解法一

##### 分析步骤

- 看到回文子串问题，首先想到dp解法，子串是从i到j的下标，所以还要用二维的dp解法
- 既然确定了dp解法，那么就要考虑状态转移方程，dp[i][j]=(dp[i+1][j-1]&&s[i]==s[j])
- 状态转移方程得到了，还需要处理边界条件，dp[i][i]=true, dp[i][i+1]=(s[i]==s[i+1]) **(这两个条件分别是长度为一盒长度为二的子串)**
- 接下来就是遍历这个二维数组，使得判断每一种情况，但是遍历也有技巧，我第一次做的时候是从头到尾，依次遍历，但是我们看状态方程可以发现，是先要有dp[i+1][j-1]的值才能准确判断dp[i][j]的值，所以行数至少是从下往上遍历，接着j也不能比i小，（哪有后面的下标比前面的小的）
- 最后将判断出true的子串更新，找出最长的就解决了

##### 代码演示

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n=s.size();
        int ans=1;
        int begin=0;
        vector<vector<bool>>dp(n,vector<bool>(n,false));
        for(int i=n-1;i>=0;i--)
        {
           
            for(int j=i;j<n;j++)
            {
                if(i==j)
                {
                    dp[i][j]=true;
                    
                }
                else if(i+1==j)
                {
                    dp[i][j]=(s[i]==s[j]);
                }
                else{
                    dp[i][j]=(dp[i+1][j-1]&&(s[i]==s[j]));
                }
                 if(dp[i][j]==true&&j-i+1>ans)
            {
               ans=j-i+1;
               begin=i;
            }
            }
           
        }
         return s.substr(begin, ans);
    }
};
```

#### 解法二

##### 分析步骤

- 与上一个解法不同的是，在这个解法中，我是用长度来进行完善dp数组，也就是先判断长度为2，一直到长度为n。换一种说法就是上一个解法是横着遍历，从下到上，从左到右。这个解法是斜着遍历，从左上到右下，一点一点往右走

##### 代码展示

```c++
class Solution {
public:
    string longestPalindrome(string s) {
       int n = s.size();
        if (n <= 1) return s; // 边界情况处理
        vector<vector<bool>>dp(n,vector<bool>(n,false));
       int start=0;
       int len=1;
       for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }
        for(int L=2;L<=n;L++)
        {
            for(int i=0;i<n;i++)
            {
               int j=i+L-1;
               if (j >= n) break; // 超出边界
               if(s[i]!=s[j])
               {
                dp[i][j]=false;
               }
               else
               {
                if(L<=2||dp[i+1][j-1])
                {
                    dp[i][j]=true;
                    if(L>len)
                    {
                        start=i;
                        len=L;
                    }
                }
               }
            }
        }
       return s.substr(start, len);
        
    }
};
```

‍

## 例题三：编辑距离问题

### 题目

给你两个单词 `word1`​ 和 `word2`​， *请返回将* *​`word1`​*​ *转换成* *​`word2`​*​ *所使用的最少操作数*  。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

**输入：** word1 = "horse", word2 = "ros"  
**输出：** 3  
**解释：**   
horse -> rorse (将 'h' 替换为 'r')  
rorse -> rose (删除 'r')  
rose -> ros (删除 'e')

**示例 2：**

**输入：** word1 = "intention", word2 = "execution"  
**输出：** 5  
**解释：**   
intention -> inention (删除 't')  
inention -> enention (将 'i' 替换为 'e')  
enention -> exention (将 'n' 替换为 'x')  
exention -> exection (将 'n' 替换为 'c')  
exection -> execution (插入 'u')

### 解题思路

- 考虑到动态规划问题，首先要知道dp数组的含义是什么，定义几维的数组
- 1. 有两个字符串，那就定义一个二维数组，
  2. 题目中说word1转为word2所需的最少操作数,那么dp[i][j]就定义为**word1的前i个字符串转化为word2的前j个字符串所需要的最少操作数**
- dp的含义知道了，接下来是解决状态转换方程
- 1. 如果word1[i]==word2[j],那么dp[i][j]就是dp[i-1][j-1]  （意味着当前不需要进行操作，只需要把**word1的前i-1个字符串转化为word2的前j-1个字符串就行，因为word1[i]==word2[j]，不用管）**
  2. 如果word1[i]！=word2[j]，那么dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1.。按照他们相等的思路再推一推就能想明白，
  3. 1. 如果min函数选到了dp[i-1][j-1]  ，那么后面的加一操作意味着替换，因为用最少的步骤把前i-1个和前j-1个转换完了，那么当前第i个和第j个字符不同，那么就把word1[i]替换为word2[j]就ok了
      2. 如果min函数选到了dp[i][j-1]，那么后面的加一操作意味着添加，因为前i个和前j-1个已经转化完了，而且是步骤最少，现在的情况是word1前i个和word2前j-1个完全匹配，但是word2[j]没人匹配，那么就在word1后面添加一个字符
      3. 如果min函数选到了dp[i-1][j],这个情况试着自己想一想

### 代码展示

```c++
class Solution {
public:
     int fun(int a,int b,int c)
     {
        int t=min(a,b);
        return min(t,c);
     }
    int minDistance(string word1, string word2) {
        int n1=word1.size();
        int n2=word2.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,n1+n2+1));
        for(int i=0;i<=n1;i++)
        {
            dp[i][0]=i;
        }
         for(int i=0;i<=n2;i++)
        {
            dp[0][i]=i;
        }
        for(int i=1;i<=n1;i++)
        {
            for(int j=1;j<=n2;j++)
            {
                if(word1[i-1]==word2[j-1])
                {
                    dp[i][j]=dp[i-1][j-1];
                }
                else
                {
                    dp[i][j]=fun(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1;
                }
            }
        }
        return dp[n1][n2];
    }
};
```

## 例题四：最长有效括号

### 题目：

给你一个只包含 `'('`​ 和 `')'`​ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1**

**输入：** s = "(()"  
**输出：** 2  
**解释：** 最长有效括号子串是 "()"

**示例 2：**

**输入：** s = ")()())"  
**输出：** 4  
**解释：** 最长有效括号子串是 "()()"

**示例 3：**

**输入：** s = ""  
**输出：** 0

### 解题思路：

- 我首先想到的是用栈来解决，但是最后一提交才发现是自己想简单了，因为一种情况就完了“()(()”,具体怎么用栈做我就没有思考了。

- 回归正题，用动态规划吧，还是先来定义dp[i]数组的意义，一般dp数组的定义都是前i个字符满足条件的答案。那么这道题也是一样，前i个字符最长的有效长度，一旦知道这个定义，那么就能知道只有在s[i]==')'时dp才可能有数值（因为完整的有效括号是以‘）’结尾的）
- 接下来就是想状态转化方程，如果当前判断的字符是‘（’那就直接跳过，并且对应的dp设置为0.。
- 如果当前判断的是‘）’，
- 1. 先看它的前一个字符是什么
  2. - 如果是左括号：那就是这种形式“......()”不管这一对括号前面是什么，只需要将当前的dp[i]=2+dp[i-2]
      - 如果是右括号（稍微麻烦点）：形式是这样“......((()))”。s[i-1]也是一个右括号，那他的dp可能也有个数值，如果有数值，那么就代表这是内层的括号，数值是以s[i-1]为结尾的最长括号个数，当前判断的s[i],那就要检查检查中间这些组合好的括号的开头有没有一个左括号来和当前右括号匹配，要是有，那么dp[i]=dp[i-1]+2+dp[i-nums-2]..。。nums=dp[i-1] (理解为中间那些组好的括号)。要没有，那dp[i]就是0.
- 现在已经给出所有的状态转换方程，接下来就是写出代码，我第一次写的时候为了不考虑边界条件，就把dp数组的个数定义为n+1,也不太好做，需要好好想想下标直接的关系。下面展示代码

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int n=s.size();
        vector<int>dp(n+1,0);
        int ans=0;
        for(int i=1;i<=n;i++)
        {
           if(s[i-1]=='(')//当遇到左括号，直接跳过
           {
            continue;
           }
           else//当前为右括号
           {
            if(i-2>=0&&s[i-2]=='(')//上一个为左括号时
            {
                dp[i]=dp[i-2]+2;
            }
            else if(i-2>=0&&s[i-2]==')')//上一个为右括号时
            {
                int nums=dp[i-1];
                if(i-1-nums-1>=0&&s[i-1-nums-1]=='(')//跳过中间那些组合好的括号，看看那边有没有左括号来把中间包围起来
                {
                  dp[i]=dp[i-1]+2+dp[i-nums-2];
                }
                else{//要是没有就算了，设置为零
                    dp[i]=0;
                }
            }
            else{
                dp[i]=0;
            }
            
           }
           ans=max(ans,dp[i]);//找出dp中的最大值
        }
        return ans;
    }
};
```

## 题型：买卖股票的最佳时机

### 题目：

给定一个整数数组`prices`​，其中第   `prices[i]`​ 表示第 `i`​ 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

**输入:**  prices = [1,2,3,0,2]  
**输出:**  3  
**解释:**  对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

**示例 2:**

**输入:**  prices = [1]  
**输出:**  0

### 解题思路

1. 首先肯定能想到用动态规划来解答，但是就是想不到状态方程，也不知道用几维的dp数组
2. 那么先来定义dp数组，n行3列，
3. - dp[i][0]:如果把第i天的股票买进（或者说在第i天之前买进），反正今天是有股票的情况，能累计多少钱，
    - dp[i][1]:如果在第i天把股票卖出，能累计多少钱
    - dp[i][2]:如果第i天啥也不干，能累计多少钱
4. 其实第i天无非就是干这三件事，1买进股票，2卖出股票，3啥也不干
5. 那么我们在来看看题目，说是卖出股票后的一天啥也不能干，那么最简单的状态方程就能写了
6. - dp[i][2]=max(dp[i-1][1],dp[i-1][2])。解释：第i天啥也不干有两种可能，

      1.   **昨天已经把股票卖了，题目规定今天不让干，那么今天啥也不干的收益就是昨天卖了股票的收益dp[i-1][1]。**
      2.  **今天单纯不想干。那么今天啥也不干的收益就是昨天啥也不干的收益dp[i-1][2]。**
7. 现在一个状态方程已经解决，接下来来解决今天如果要买股票咋办，也能对应两种情况
8. - dp[i][0]=max(dp[i-1][0],dp[i-1][2]-prices[i]);下面来解释两种情况
    - 1. 今天想买股票，那么昨天就不能卖（因为有题目要求），所以不能用昨天卖股票后的钱来买
      2. 要想今天买股票 **，那就要昨天啥也不干的钱来买，dp[i-1][2]-prices[i]，这个结果是昨天啥也没干，今天把股票买了**
      3. **如果你昨天已经买了，那就是dp[i-1][0].这两种情况取最大值，不管是你之前买的也好，今天买的也好，反正今天你手上是有股票的，而且买了股票后的最大积累就是dp[i-1][0]**
9. 现在两个状态方程已经写完，就剩最后一个
10. - dp[i][1]=dp[i-1][0]+prices[i];既然了解了dp[i][0],那就很好解释这个了
     - 1. 在第i天把股票卖出，那前提是你要有这个股票，而dp[i-1][0]的数量就是你在昨天已经有股票了，而且是累计最大的金额获得的股票，那么今天把股票卖出的金额就是，**昨天的买完股票后的钱+今天股票的价钱**
11. 结束，剩下的就是很简单的代码部分

### 代码部分

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        if(n==1)
        {
            return 0;
        }
        vector<vector<int>>dp(n,vector<int>(3,0));
        dp[0][0]=-prices[0];
        for(int i=1;i<n;i++)
        {
            dp[i][0]=max(dp[i-1][0],dp[i-1][2]-prices[i]);
            dp[i][1]=dp[i-1][0]+prices[i];
            dp[i][2]=max(dp[i-1][1],dp[i-1][2]);
        }
        return max(dp[n-1][1],dp[n-1][2]);
        
    }
};
```

‍
